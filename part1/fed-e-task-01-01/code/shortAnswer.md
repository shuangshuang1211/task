## 简答题

#### 谈谈你是如何理解 JS 异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

**答:**
   - 因为js一开始是针对浏览器的脚本语言，需要用它来操作DOM，若js可以多线程进行，则容易造成在删除增加DOM时候出现问题，所以js是单线程的(代码从上到下依次执行)。但浏览器不是，为了提升性能，浏览器会先在调用找依次执行同步代码，对于异步代码会等异步任务完成后将异步回调处理函数加入等待执行的任务队列(先进先出);
  - 调用找实行先进后出原则，会保存代码执行期间所有执行上下文，排队的任务会依次push进调用找执行后清除;
  - 当有多个异步任务(即所谓的宏任务)时，后执行的异步代码比之前的异步代码先返回结果，这时，会让先得到返回结果的异步回调先进入任务队列；若这个异步任务执行后还有其他的后续任务处理(微任务)，会继续执行完当前所有的微任务才会执行下一个宏任务
  - 整体script代码相当于首个宏任务，宏任务有: setTimeOut、setInterval、requestAnimationFrame(浏览器)、I/O、用户交互事件(浏览器)等;
  - 微任务：process.nextTick(针对Node)、promise链式调用的函数(then catch finally)、MutationObserver；
  - 所以整体执行逻辑是，先执行同层级代码的宏任务，再执行当前宏任务下的微任务(包含微任务后又产生的微任务)，等同层级微任务执行完毕再执行下一个宏任务...这样就形成事件的循环

  - JS 异步编程

  JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。

- EventLoop 事件环和消息队列

  **EventLoop** 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。

  **消息队列** 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。

  一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。

  当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。

  然后再取出一个宏任务执行。以此循环...



- 宏任务与微任务

  **宏任务**可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

  浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。

  宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等



  **微任务**可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。

  所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。

  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等