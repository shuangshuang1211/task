# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```

```.md
最终结果是：10
  1. 代码执行时，首先浏览器会开辟一片内存空间(ECS),ECS会有VOG在桟底；
  2. 变量提升，此时会在VOG 内会声明两个变量，一个是a： undefiend；i: undefined；
  3. 执行 a = []，a会指向一个保存着一个空数组的堆内存地址(假设是ox000)，所以 a: ox000；
  4. 执行 for循环，i：0，此时i<10, 所以继续执行 循环体代码，给a[i]赋值，所以此时 ox000中就是{0: 匿名函数fn1的地址}，fn1定义时，确定了fn1的作用域是：ECG，没有其他变量，并在这块地址内以字符串的形式保存了匿名函数的代码
  5. 最后执行i++, 则VOG中的i: 1，再继续第4、5步
  6. 到i= 10时，i不满足循环条件，则退出循环此时i=10；a是长度为10，每个值为单独的一个函数数组
  7. a[6]()其实就是调用在堆内存中一个匿名函数(假设是fn6，fn6 跟fn1除了内存地址不一样scope和代码一样)，这个函数执行时(确定作用域链: <ECG>, 确定this(没有)， 初始化arguments， 形参赋值，变量提升，执行代码)，会创建一个EC(fn6),此时AO没有i，所以会继续向作用链上层ECg中找，这里有i = 10，所以会打印10
```

　

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

```
最终结果会报出 ReferenceError；这是因为if代码块中用let申明了tmp，let关键字声明的变量作用域只会在if块语句内部，且在解析执行代码时，js引擎也会注意出现在之后的let声明，不过在此之前不能引用任何方式来引用未声明的变量，在let申明变量之前引用了这个变量的代码执行的瞬间被称为暂时性死区，在此阶段引用任何后面声明的变量都会报ReferenceError错；
```

　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

```js
const minValue = arr.reduce((arr, cur) => arr > cur ? cur : arr, arr[0]);
```

　

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别

```
var: 1.var 声明的变量是包含他的函数的一个局部变量，可以进行变量提升，即在声明之前可以使用，但是值是undefiend；
 		 2.在全局作用域用var声明的变量会成为window的一个属性，在非严格模式下，在函数内部如果不用关键字声明的变量会成为一个全局变量
 		 3.var声明的变量可以重复申明，后面的声明会覆盖前面的值
let: 1.let声明的变量的作用域是块，在块级作用域内提前使用这个变量因为let的暂时性死区的特性也会报错；
     2.在全局作用域下声明的变量不会成为window的一个属性
     3.let声明的变量不能重复声明，但能重新赋值
const: const 与let类似，但是const 在变量声明时就需要初始化，且初始化后值不可以改变
```

　

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

```
最终结果是： 20
this在标准函数中，this会指向把该函数当成方法调用的执行上下文对象；在箭头函数中this会指向定义时所处的上下文对象
这里fn是标准函数且是通过obj直接调用执行，this会指向调用者obj，所以是obj.a为20，如果把obj.fn用一个变量先接受，后调用这个变量，那这时，this指向的就是全局变量对象(浏览器下就是window)，如果在obj中用箭头函数定义fn，则此时无论怎么调用这里的this都会指向全局执行上下文对象
```

　

### 6. 简述Symbol类型的用途

​	Symbol可以产生一个独一无二的值，作为唯一 的标识，这个值可以用来作为对象的属性，避免出现相同的属性名被改写或覆盖，或者作为类的一个私有属性名，在类中用Symbol定义一个变量作为私有属性或方法名，一般来说只在类内部才能拿到这个变量（但是通过Reflect.ownKeys(类.prototype)其实也能拿到）　

### 7. 说说什么是浅拷贝，什么是深拷贝？

​	　浅拷贝和深拷贝主要是针对引用类型的数据而言，浅拷贝只拷贝引用类型的内存地址，即新对象的引用值与旧对象的值占同一个内存空间，如果改变其中任何一个值都会影响另外一个值；而深拷贝则会对引用类型的值再重新开辟一片内存空间存当前对象，且他们之间相互独立，对各自操作将不会影响另外的值。

### 8. 请简述TypeScript与JavaScript之间的关系？

　  ts相较于js，帮助js在语法层面上规避了一些语法错误，让js能在编写的时候以强类型与静态类型的语言的编写方式来完成，ts包含了js的所有元素，同时也可以直接载入js文件运行，在此基础上ts还扩展了一些js的语法

　

### 9. 请谈谈你所认为的typescript优缺点

　	优点：

1. ts通过类型注解提供编译时的静态类型检查，对数据限定明确 的类型，规避了因某些类型问题造成的代码上错误，也便于在编码阶段就找到错误和调式；

   2. 应用于大型项目开发中，对于代码的重构变更更容易检查到相关内容代码变更需求，对于多人协作开发也保证了代码的质量和统一等



      缺点：

      1. ts对于代码量较少的项目来说，会增加额外的工作负担；
      2. 不够灵活

　

### 10. 描述引用计数的工作原理和优缺点

　原理：计数器会记录每个对象的被引用次数，每次引用关系修改就会改变，当对象的引用次数为0就立即对这块内存地址进行清理；

   优点： 及时清理

   缺点： 不能清除存在循环引用的数据，每次都会查找当前的引用次数可能会导致性能的问题

　

### 11. 描述标记整理算法的工作流程

　标记阶段：从根节点(一般是全局变量对象)开始查找，如果子节点能访问到则表示该子节点的引用对象是可达的，则进行标记，这样递归进行直到最后子节点，那些没有被标记的节点对象就是需要删除的对象

  整理阶段：对标记的内容进行整理，整理到内存的一侧

  清除阶段：对未标记的内容进行清除

　

### 12.描述V8中新生代存储区垃圾回收的流程

　新生代存储区一般存储存活时间较短或所占空间较小的对象，在这里它又会分为 From-Space 和 To-space区域，主要用到标记整理和空间复制

   From-Space: 对此区域的活动对象进行标记

   To-Space: 把from-space的标记对象复制到to-space（空间换时间），并对这些对象在内存中进行有序的排列

   清除from-space中未被标记的内容，交换from-sapce和to-sapce

​	在新生代中其实又分为 nursery  子代和 intermediate子代，数据第一次进来时放在nursery子代，经过一次垃圾回收后还存在就进入到intermediate子代，再经过一次垃圾回收还存在则会晋升到老生代，当然，如果标记的数据比较大时应该也会进入到老生代

### 13. 描述增量标记算法在何时使用及工作原理

　 当在老生代垃圾存在比较多时，这是为了避免造成全停顿现象，会采用增量标记，这是对标记阶段进行的一些优化，即：

​     标记一段js执行一段这样循环标记，如果在这个过程中，浏览器认为内存还够用，也会延迟清理，因为标记了一段js又执行，所以此时应该需要一些屏障技术来记录每个变量对象的引用关系，以确保js会用到没有标记的内容避免错误